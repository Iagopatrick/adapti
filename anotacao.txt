Rever a explicacao das rotas

nao se esquecer que e preciso ter o accept no header do cliente para identificar que ele consegue tratar o retorno do tipo json

dentro do metodo update e preciso configurar para ser possivel utilizar o endpoint patch => Para isso e preciso percorrer as regras existentes e verificar quais foram selecionadas para serem mudadas

UPLOAD DE ARQUIVOS
Os arquivos nao vem no array de atribtos, mas sim num array de imagem

Para a persitencia de arquivos (salvar) basta recuperar o arquivo $image = $request->file('imagem')
$image->store('imagens', 'public') //imagens aqui e` o diretorio aonde sera salvo o arquivo. Para verificar esses diretorios ha os diretorios em filesystens na pasta config.





php seção 8:
é possivel incluir tabelas pelo proprio framework laravel, usando uma migration que contem apenas regras de inclusão de novas tabelas
default -> Valor padrão para caso o valor nao seja passado na criação da tabela
nullable -> Valor que pode ser vazio
O esquema de chave estrangeira foi feito de forma diferente que foi ensinado no ps

After -> criação de uma coluna após uma coluna já criada 
Comandos das migrate:
Status -> Mostra as migrates e demonstra se já foram executadas ou nao
Reset -> Reverte as alterações do banco, executa o método down
Refresh -> Reverte as migrações e depois executa novamente o comando de criação
Fresh -> Ele dropa os elementos e recria as migration

Eloquent ORM - Object Relation Map
Método para mapear dados entre o banco de dados e a aplicação

Tinker -> Console interativo que da acesso as classes do projeto pelo terminal 

O teste do eloquent usando a tecnologia do tinker é mais eficiete.
Os atributos são criandos em tempo real, enquanto se testa a classe, respeitando as colunas da tabela respectiva.
Quando há alterações no código fonte é preciso reiniciar o tinker para ele atualizar e manter as mudanças feitas.

Com o uso do all() é possivel recuperar todas instancias de determinada tabela
É possível fazer um foreach para percorrer o array dos atributos de cada objeto na tabela
Com o uso do find(primer_key) é possivel achar o objeto que foi requerido
where(), whereIn(), whereNotIn(), com base na igualdade, whereBetween(), whereNotBetween(), com base em um intervalo.
É possível colocar mais parametros para pesquisar com o where. orwhere() pode ser usado como uma forma de usar o 'or'.
<> -> diferente
whereNull() e whereNotNull().
Collections -> coleção de dados, possibilidade de conseguir lidar com o retorno da consulta com o eloquent
first, last, reverse -> first retorna o primeiro elemento do 'array', last o ultimo e o reverse reverte a ordem do 'array'
toArray() e toJson().
pluck('chave') -> recupera todos os valores de uma determinada chave.
                                Atualizando regristros
depois de alterarmos dados de algum objeto podemos salvar as atlterações no banco através do save().
com o fill(['nome' => 'novo nome',...]) podemos alterar os dados com um array associativo.
Podemos combinar o where() com o update() para mudar registros com atributos localizados pelo filtro.
delete() -> podemos combinar da mesma forma que o save ou update.
softDelete -> É preciso mudar a migration da classe que tera o softDelete para ter o campo do mesmo na sua tabela. Ela controla as
remoções feitas. É possivel recuperar aqueles dados que foram deletados pelo softDelete através do onlyTrashed()